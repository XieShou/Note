# xLua源码：LuaEnv

先看一个案例：

```csharp
void Start()
{
    LuaEnv env1 = new LuaEnv();
    env1.DoString("a = 1");
    env1.DoString("print('env1.a = ' .. tostring(a))");
    LuaEnv env2 = new LuaEnv();
    env2.DoString("print('env2.a = ' .. tostring(a))");
})");
```

结果如下：

```
env1.a = 1
env2.a = nil
```

可以简单的分析下，得到结论：xLua的两个LuaEnv对应Lua层的两个不同的Lua虚拟机，彼此之间存在内存隔离。

听坊间传闻，有使用者为了避免内存泄漏，一个玩法场景对应一个LuaEnv，在退出时销毁。

同时在源码中对虚拟机进行交互时，要像写Lua的C部分一样，带上对应的L参数，例如：

```csharp
public class SystemObjectWrap 
{
    public static void __Register(RealStatePtr L){ //... }
}
```

## 从LuaEnv开始

首先看到LuaEnv的构造函数，`LuaEnv.cs`：

```csharp
public class LuaEnv : IDisposable
{
    //...
    public LuaEnv()
    {
        //step1：检查LuaDLL版本是否和编辑器中脚本一致
        if (LuaAPI.xlua_get_lib_version() != LIB_VERSION_EXPECT)
        {
            throw new InvalidProgramException("wrong lib version expect:"
                + LIB_VERSION_EXPECT + " but got:" + LuaAPI.xlua_get_lib_version());
        }
        //step2：拿到Lua中的LUA_REGISTRYINDEX
        LuaIndexes.LUA_REGISTRYINDEX = LuaAPI.xlua_get_registry_index();
        //step3：创建虚拟机，初始化基础库
        rawL = LuaAPI.luaL_newstate();
        LuaAPI.luaopen_xlua(rawL);
        LuaAPI.luaopen_i64lib(rawL);
        //step4：初始化这个LuaEnv类实例对应的ObjectTranslator
        translator = new ObjectTranslator(this, rawL);
        translator.createFunctionMetatable(rawL);
        translator.OpenLib(rawL);
        ObjectTranslatorPool.Instance.Add(rawL, translator);

    }
    //...
}
```
